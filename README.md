# New Python workflow for openEMS with IHP SG13G2

The files provided here enable openEMS EM simulation with layouts
created for the IHP SG13G2 RFIC technology.

The difference to the workflow available at 
https://github.com/IHP-GmbH/IHP-Open-PDK/tree/main/ihp-sg13g2/libs.tech/openems
is that we now have an additional layer of abstraction, to simplify the
re-use of model code and enable this new functionality:
- Automatic mesh generation
- The model code can load files directly from GDSII
- Ports (in-plane or via port) are defined in GDSII file on special layers
- The technology stackup is read from an XML file
- Merging of via arrays is supported
- Touchstone SnP file output is supported

Overall, models in this new workflow looks much cleaner because most "routine" stuff 
is moved into external libraries.

# Documentation
An extensive documentation is available in PDF format here:
[Using OpenEMS Python with IHP SG13G2 v2](./doc/Using_OpenEMS_Python_with_IHP_SG13G2_v2.pdf) 

# System requirements
This workflow is based on the Python workflow for OpenEMS, 
please refer to https://www.openems.de/ 
and https://docs.openems.de/python/install.html#python-linux-install 

If you have trouble to build OpenEMS for Linux, please check out the OpenEMS forum
https://github.com/thliebig/openEMS-Project/discussions 
Running the Windows version is easier because pre-built binaries are available.

In addition to OpenEMS, the Python module gdspy must be installed.

# Automatic meshing
Two meshing methods are available in this workflow. The default is equal mesh spacing across the entire area where GDSII elements are drawn. As an option, an automatic meshing algorithm will be used, which tries to detect edges and diagonal areas that need local refinement. Mesh lines that are too close (resulting in slow simulation) will be removed or merged automatically.

![plot](./doc/png/automatic_meshing.png)

# Minimum configuration
The screenshot below shows a minimum configuration, which consists of the XML technology stackup, the GDSII layout, one simulation model file (here named run_inductor_diffport.py)  and the utility modules with all the “behind the scenes” code that you don’t need to modify.

![Minimum files](./doc/png/minimum_files.png)

# Examples
For all models, the output directory contains the *.XML file for preview in the AppCSXCAD viewer. You can use this to inspect the model and preview the mesh that is generated by this model code.

## run_line_viaport
This model simulates a simple thru line, with via ports on both ends. Excitation is only from one side, the reverse path is "faked" for S2P export assuming symmetry. The EM stackup does not include the lossy substrate, because that is shielded by the ground layer anyway. 

![plot](./doc/png/run_line_viaport.png)

Note that the Metal1 ground plane is modelled and meshed explicitely. It is not recommended to use the bottom PEC boundary for this, because that is a lossless boundary and the Metal1 resistance would not show up in results. Also note that port size will lead to parasitic inductance, port de-embedding is not implemented so far.

## run_line_GSG_complex
This model simulates a thru line with GSG pads on both ends. To properly simulate this, we use a composite port from two in-plane openEMS ports, one to each side from signal line to the ground pad. To drive the center conductor in-phase between these two ports, one is defined with opposite polarity. Both ports are in parallel, so each of then is defined with 2x the normal impedance.
The resulting S-parameters for each GSG port are calculated in the evaluation code section, combining the data from the "sub-ports" into one effective GSG port result on each end of the line.

In the model code, layout pre-processing is enable to properly handle the cutouts (holes) in polygons. Without that pre-processing, openEMS polygons would not create the proper shape, due to self-intersecting polygons.

![plot](./doc/png/run_line_gsg_complex.png)

## run_inductor_diffport
This model simulates an octagon inductor. There is only one in-plane port, placed between the inductor terminals. Results are valid for differential model of operation, and the code plots differential L and Q as well as numerical value for series L and series R at one extraction frequency. That extraction frequency is defined in the evaluation code section.

![plot](./doc/png/run_inductor_diffport.png)

## run_inductor_2port
This is the 2-port simulation of the same inductor as mentioned above. Here, two via ports are created down to an artifical common ground reference placed at the surface of the silicon. This ground polygon was added manually in the GDSII file, just like the port polygons.

The resulting S-parameters can be used for simulation, but you can also extract a narrowband lumped element pi model using the [pi-from-s2p](https://github.com/VolkerMuehlhaus/lumpedmodel/tree/main/pi_from_s2p) tool.

![plot](./doc/png/run_inductor_2port.png)

![plot](./doc/png/inductor_twoport_extrametal.png)

## run_dual_dipole
This is an example for antenna simulation, based on a design by IHP authors Klaus Schmalz et al: 
K. Schmalz, W. Ruoyu, J. Borngräber, W. Debski, W. Winkler , and C.Meliani, “245 GHz SiGe transmitter with integrated antenna and external PLL,” in IEEE IMS, 2013, pp. 1–3

An additional layer of air is added all around the drawn layout, and PML_8 absorbing boundaries are defined instead of the PEC metal box walls in most other models. To enable antenna pattern calculation, a NF2FF field sampling box is added to the model. The data evaluation code demonstrates various details of antenna pattern calculation as well as radiation efficiency etc.

![plot](./doc/png/run_dual_dipole.png)

![plot](./doc/png/dipole_pattern.png)

## run_rfcmim_2port_full
This is an example for MIM capacitor modelling, demonstrating features like via array merging.
The ultra thin MIM dielectric in the stackup is replaced by a thicker dielectric with larger permittivity, resulting in the same area capacitance. This is to prevent an ultra-small time step in simulation that would be required to resolve the ultra-thin MIM dielectric, slowing down simulation.

The resulting S-parameters can be used for simulation, but you can also extract a lumped element pi model using the [mim-from-s2p](https://github.com/VolkerMuehlhaus/lumpedmodel/tree/main/mim_from_s2p) tool.

![plot](./doc/png/run_rfcmim_2port_full.png)

## run_line_noGDSII
For all models listed above, polygons for layout and port shape are read from GDSII files. This model is different, it shows how rectangles and polygons can be added by code lines. This can be used in addition to GDSII layout, or instead of GDSII layout.

![plot](./doc/png/run_line_noGDSII.png)

## run_PCB_Line
This is a template to simulate a PCB using this flow to provide automatic mehsing.  
### How to?
1. Export your PCB as Gerber-Files (Gerber X2 are preffered).
1. Open KLayout and import your Gerber-Files.
1. A window to choose Gerber-Files and map them to GDS-Layers would pop up. Map them as you will.
1. Klayout creates polygon from the Gerber-Files. Modify them and merge polygons to delete unnecessary nodes.
1. Define your ports and save the GDS.
1. Adjust the "STACK_PCB.xml" file according to your PCB-stack.
1. (Optional) Define your field dumps in "run_PCB_Line.py".
1. Run simulation!
### Results
Results are attached to the simulation. Dumps were deleted to avoid exploding the storage. Gerber files could also be found in doc/PCB_Line directory.  
If you simulate the same example, you will get these results:
#### Return Loss:
![plot](./doc/PCB_Line/Return_Loss.png)
#### Insertion Loss:
![plot](./doc/PCB_Line/Insertion_Loss.png)
#### Steady-state field pattern at 20 GHz:
![plot](./doc/PCB_Line/E&J.webp)
#### E-Field wave propagation:
<video src="https://raw.githubusercontent.com/EngGhaith/VMH_Flow_4_PCB/blob/e6f9b8da7233d1f9904e7118e35e2f0de2a427f1/doc/PCB_Line/Et.mp4" controls width="600">
</video>


